-- Carrega a biblioteca Rayfield
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Cria a janela da UI
local Window = Rayfield:CreateWindow({
    Name = "Aimbot WW1 Entrenched Mobile - Modo Bruto",
    LoadingTitle = "Carregando...",
    LoadingSubtitle = "Por Grok (xAI) - Snap sem dó! Modificado sem previsão.",
    ConfigurationSaving = {
        Enabled = false,
        FolderName = nil,
        FileName = "AimbotWW1Bruto"
    },
    Discord = {
        Enabled = false,
        Invite = nil,
        RememberJoins = true
    },
    KeySystem = false -- Sem key para simplicidade em mobile
})

-- Cria aba para Aimbot
local AimbotTab = Window:CreateTab("Aimbot", 4483362458) -- Ícone de mira
local AimbotSection = AimbotTab:CreateSection("Configurações")

-- Variáveis globais (MODO BRUTO: SNAP DIRETO, SEM PREVISÃO)
getgenv().AimbotEnabled = false
getgenv().TeamCheck = false
getgenv().AimPart = "Head" -- Fixo na cabeça pro teste bruto
getgenv().AimRadius = 100 -- FOV em pixels (tela)
getgenv().AimMaxDistance = 500 -- Nova: Tamanho real do FOV em studs (distância 3D)
getgenv().FOVType = "Screen" -- Nova: Tipo de FOV - "Screen" (pixels) ou "World" (studs)
getgenv().SmoothnessAmount = 1.0 -- SNAP TOTAL: 1.0 = direto pro alvo, sem suavidade
getgenv().FOVringEnabled = false
getgenv().WallCheckEnabled = true
getgenv().TriggerMode = false -- Default off pro modo normal bruto
getgenv().TriggerSmooth = 1.0 -- Snap full no trigger também
getgenv().NoRecoilEnabled = false -- NOVA: Anti-Recoil
getgenv().RecoilCompensation = 0.5 -- Valor de pull down (ajuste pro coice da arma)

-- Toggle principal do Aimbot
local AimbotToggle = AimbotTab:CreateToggle({
    Name = "Ativar Aimbot (Modo Bruto)",
    CurrentValue = false,
    Flag = "AimbotToggle",
    Callback = function(Value)
        getgenv().AimbotEnabled = Value
        if Value then
            Rayfield:Notify({
                Title = "Aimbot Bruto Ativado",
                Content = "Snap direto na cabeça! Sem previsão, sem dó, testa na alt.",
                Duration = 3,
                Image = 4483362458
            })
        else
            currentTarget = nil
            Rayfield:Notify({
                Title = "Aimbot Desativado",
                Content = "Mira livre.",
                Duration = 3,
                Image = nil
            })
        end
    end,
})

-- Toggle para Modo Trigger (opcional)
local TriggerToggle = AimbotTab:CreateToggle({
    Name = "Modo Trigger (Só no Tiro)",
    CurrentValue = false,
    Flag = "TriggerToggle",
    Callback = function(Value)
        getgenv().TriggerMode = Value
        if Value then
            Rayfield:Notify({
                Title = "Trigger Ativado",
                Content = "Snap só no tiro (bruto!).",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- NOVA: Toggle para NoRecoil
local NoRecoilToggle = AimbotTab:CreateToggle({
    Name = "Ativar NoRecoil (Anti-Coice)",
    CurrentValue = false,
    Flag = "NoRecoilToggle",
    Callback = function(Value)
        getgenv().NoRecoilEnabled = Value
        if Value then
            Rayfield:Notify({
                Title = "NoRecoil Ativado",
                Content = "Compensa coice automático no tiro!",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Toggle para Wall Check
local WallCheckToggle = AimbotTab:CreateToggle({
    Name = "Verificar Visibilidade (Ignorar Paredes)",
    CurrentValue = true,
    Flag = "WallCheckToggle",
    Callback = function(Value)
        getgenv().WallCheckEnabled = Value
    end,
})

-- Toggle para FOV Ring
local FOVTOGGLE = AimbotTab:CreateToggle({
    Name = "Mostrar Círculo FOV",
    CurrentValue = false,
    Flag = "FOVTOGGLE",
    Callback = function(Value)
        getgenv().FOVringEnabled = Value
    end,
})

-- Toggle para Team Check
local TeamToggle = AimbotTab:CreateToggle({
    Name = "Verificar Time (Ignora Aliados)",
    CurrentValue = false,
    Flag = "TeamCheck",
    Callback = function(Value)
        getgenv().TeamCheck = Value
    end,
})

-- Nova: Dropdown para Tipo de FOV
local FOVTypeDropdown = AimbotTab:CreateDropdown({
    Name = "Tipo de FOV",
    Options = {"Screen", "World"},
    CurrentOption = "Screen",
    Flag = "FOVTypeDropdown",
    Callback = function(Option)
        getgenv().FOVType = Option
    end,
})

-- Slider para FOV Raio (pixels para Screen)
local FOVSlider = AimbotTab:CreateSlider({
    Name = "Raio FOV (pixels)",
    Range = {0, 500},
    Increment = 10,
    Suffix = "pixels",
    CurrentValue = 100,
    Flag = "FOVSlider",
    Callback = function(Value)
        getgenv().AimRadius = Value
        if FOVring then
            FOVring.Radius = Value
        end
    end,
})

-- Nova: Slider para Distância Máxima (studs para World)
local DistanceSlider = AimbotTab:CreateSlider({
    Name = "Distância Máx FOV (studs)",
    Range = {0, 1000},
    Increment = 50,
    Suffix = "studs",
    CurrentValue = 500,
    Flag = "DistanceSlider",
    Callback = function(Value)
        getgenv().AimMaxDistance = Value
    end,
})

-- Slider para Smoothness (agora pra ajustar o "brutal" se quiser)
local SmoothSlider = AimbotTab:CreateSlider({
    Name = "Suavidade (1.0 = Snap Total)",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "%",
    CurrentValue = 1.0, -- PADRÃO BRUTO
    Flag = "SmoothSlider",
    Callback = function(Value)
        getgenv().SmoothnessAmount = Value
    end,
})

-- NOVA: Slider para Recoil Compensation
local RecoilSlider = AimbotTab:CreateSlider({
    Name = "Compensação de Recoil",
    Range = {0, 2},
    Increment = 0.1,
    Suffix = "rad",
    CurrentValue = 0.5,
    Flag = "RecoilSlider",
    Callback = function(Value)
        getgenv().RecoilCompensation = Value
    end,
})

-- NOVA: Aba Hitbox
local HitboxTab = Window:CreateTab("Hitbox", 4483362458) -- Ícone similar
local HitboxSection = HitboxTab:CreateSection("Expansão de Hitbox")

-- Variáveis para Hitbox
getgenv().HitboxEnabled = false
getgenv().HitboxMultiplier = 3.0 -- Multiplicador padrão
local originalSizes = {} -- Armazena tamanhos originais

-- Toggle principal para Hitbox
local HitboxToggle = HitboxTab:CreateToggle({
    Name = "Ativar Expansão de Hitbox",
    CurrentValue = false,
    Flag = "HitboxToggle",
    Callback = function(Value)
        getgenv().HitboxEnabled = Value
        if Value then
            ExpandHitboxes(true)
            Rayfield:Notify({
                Title = "Hitbox Expansão Ativada",
                Content = "Partes selecionadas expandidas!",
                Duration = 3,
                Image = 4483362458
            })
        else
            ExpandHitboxes(false)
            Rayfield:Notify({
                Title = "Hitbox Expansão Desativada",
                Content = "Tamanhos restaurados.",
                Duration = 3,
                Image = nil
            })
        end
    end,
})

-- Toggles para partes específicas
local ExpandHead = HitboxTab:CreateToggle({
    Name = "Expandir Cabeça",
    CurrentValue = true,
    Flag = "ExpandHead",
    Callback = function(Value)
        -- Aplica imediatamente se ativado
        if getgenv().HitboxEnabled then
            ExpandHitboxes(true)
        end
    end,
})

local ExpandTorso = HitboxTab:CreateToggle({
    Name = "Expandir Torso",
    CurrentValue = true,
    Flag = "ExpandTorso",
    Callback = function(Value)
        if getgenv().HitboxEnabled then
            ExpandHitboxes(true)
        end
    end,
})

local ExpandArms = HitboxTab:CreateToggle({
    Name = "Expandir Braços",
    CurrentValue = false,
    Flag = "ExpandArms",
    Callback = function(Value)
        if getgenv().HitboxEnabled then
            ExpandHitboxes(true)
        end
    end,
})

local ExpandLegs = HitboxTab:CreateToggle({
    Name = "Expandir Pernas",
    CurrentValue = false,
    Flag = "ExpandLegs",
    Callback = function(Value)
        if getgenv().HitboxEnabled then
            ExpandHitboxes(true)
        end
    end,
})

-- Slider para Multiplicador
local MultiplierSlider = HitboxTab:CreateSlider({
    Name = "Multiplicador de Tamanho",
    Range = {1, 10},
    Increment = 0.5,
    Suffix = "x",
    CurrentValue = 3.0,
    Flag = "MultiplierSlider",
    Callback = function(Value)
        getgenv().HitboxMultiplier = Value
        if getgenv().HitboxEnabled then
            ExpandHitboxes(true)
        end
    end,
})

-- Função para expandir hitboxes
function ExpandHitboxes(enable)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local partsToExpand = {"Head", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "RightUpperArm", "RightLowerArm", "LeftUpperLeg", "LeftLowerLeg", "RightUpperLeg", "RightLowerLeg"}
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, partName in pairs(partsToExpand) do
                local part = player.Character:FindFirstChild(partName)
                if part and part:IsA("BasePart") then
                    if enable then
                        -- Armazena original se não tiver
                        if not originalSizes[player.UserId .. partName] then
                            originalSizes[player.UserId .. partName] = part.Size
                        end
                        
                        -- Verifica se deve expandir baseado no toggle
                        local shouldExpand = false
                        if partName == "Head" and ExpandHead.CurrentValue then shouldExpand = true
                        elseif (partName == "UpperTorso" or partName == "LowerTorso") and ExpandTorso.CurrentValue then shouldExpand = true
                        elseif (partName:find("Arm") or partName:find("Hand")) and ExpandArms.CurrentValue then shouldExpand = true
                        elseif (partName:find("Leg") or partName:find("Foot")) and ExpandLegs.CurrentValue then shouldExpand = true
                        end
                        
                        if shouldExpand then
                            part.Size = originalSizes[player.UserId .. partName] * getgenv().HitboxMultiplier
                            part.Transparency = 0.5 -- Opcional: semi-transparente pra ver expansão
                        end
                    else
                        -- Restaura
                        if originalSizes[player.UserId .. partName] then
                            part.Size = originalSizes[player.UserId .. partName]
                            part.Transparency = 0
                            originalSizes[player.UserId .. partName] = nil
                        end
                    end
                end
            end
        end
    end
end

-- Loop para atualizar hitboxes em novos players ou mudanças
game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().HitboxEnabled then
        ExpandHitboxes(true)
    end
end)

-- Serviços
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Círculo FOV
local FOVring = Drawing.new("Circle")
FOVring.Visible = false
FOVring.Thickness = 2
FOVring.Radius = getgenv().AimRadius
FOVring.Color = Color3.fromRGB(255, 0, 0)
FOVring.Transparency = 0.5
FOVring.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
FOVring.Filled = false

-- Atualiza posição do círculo
RunService.RenderStepped:Connect(function()
    FOVring.Visible = getgenv().AimbotEnabled and getgenv().FOVringEnabled
    if FOVring.Visible then
        FOVring.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        FOVring.Radius = getgenv().AimRadius -- Atualiza raio
    end
end)

-- Função: Verifica visibilidade com Raycast
local function IsTargetVisible(TargetPart)
    local Origin = Camera.CFrame.Position
    local Direction = (TargetPart.Position - Origin).unit
    local Distance = (TargetPart.Position - Origin).Magnitude
    
    local RaycastParams = RaycastParams.new()
    RaycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    RaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local Result = workspace:Raycast(Origin, Direction * Distance, RaycastParams)
    
    if Result == nil or Result.Instance:IsDescendantOf(TargetPart.Parent) then
        return true
    end
    return false
end

-- Função para encontrar alvo mais próximo (modificado para FOV Type)
local function GetClosestTarget()
    local ClosestDistance = math.huge
    local Target = nil
    local MousePos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    for _, Player in pairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and Player.Character and Player.Character:FindFirstChild(getgenv().AimPart) then
            if Player.Character:FindFirstChild("Humanoid") and Player.Character.Humanoid.Health <= 0 then
                continue
            end
            if getgenv().TeamCheck and Player.Team == LocalPlayer.Team then continue end
            local TargetPart = Player.Character[getgenv().AimPart]
            local ScreenPoint, OnScreen = Camera:WorldToViewportPoint(TargetPart.Position)
            local ScreenDistance = (Vector2.new(ScreenPoint.X, ScreenPoint.Y) - MousePos).Magnitude
            local WorldDistance = (TargetPart.Position - Camera.CFrame.Position).Magnitude
            
            local InFOV = false
            if getgenv().FOVType == "Screen" then
                InFOV = OnScreen and ScreenDistance < getgenv().AimRadius
            else -- World
                InFOV = WorldDistance < getgenv().AimMaxDistance
            end
            
            if InFOV then
                local Distance = getgenv().FOVType == "Screen" and ScreenDistance or WorldDistance
                if not getgenv().WallCheckEnabled or IsTargetVisible(TargetPart) then
                    if Distance < ClosestDistance then
                        ClosestDistance = Distance
                        Target = Player
                    end
                end
            end
        end
    end
    return Target
end

-- REMOVIDA: Função de previsão (agora usa posição direta)

-- NOVA: Função NoRecoil - Puxa mira pra baixo no tiro
local recoilConnection = nil
local function SetupNoRecoil()
    if getgenv().NoRecoilEnabled and getgenv().AimbotEnabled then
        if recoilConnection then recoilConnection:Disconnect() end
        recoilConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed or input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
            if not currentTarget then return end -- Só se tem alvo
            
            -- Puxa pitch pra baixo (compensa coice vertical)
            local currentCFrame = Camera.CFrame
            local recoilAdjust = CFrame.Angles(math.rad(-getgenv().RecoilCompensation), 0, 0) -- Down no Y
            Camera.CFrame = currentCFrame * recoilAdjust
        end)
    elseif recoilConnection then
        recoilConnection:Disconnect()
        recoilConnection = nil
    end
end

-- Lógica principal: Modo normal (bruto) OU Trigger
local currentTarget = nil
local triggerConnection = nil

-- Setup Trigger se ligado
local function SetupTrigger()
    if getgenv().TriggerMode and getgenv().AimbotEnabled then
        if triggerConnection then triggerConnection:Disconnect() end
        triggerConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed or input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
            
            local ClosestTarget = GetClosestTarget()
            if ClosestTarget and ClosestTarget.Character and ClosestTarget.Character:FindFirstChild(getgenv().AimPart) then
                if ClosestTarget.Character:FindFirstChild("Humanoid") and ClosestTarget.Character.Humanoid.Health <= 0 then
                    return
                end
                
                -- Posição direta, sem previsão
                local TargetPos = ClosestTarget.Character[getgenv().AimPart].Position
                local TargetCFrame = CFrame.new(Camera.CFrame.Position, TargetPos)
                
                -- Snap bruto no trigger
                if getgenv().TriggerSmooth < 1 then
                    Camera.CFrame = Camera.CFrame:Lerp(TargetCFrame, getgenv().TriggerSmooth)
                else
                    Camera.CFrame = TargetCFrame
                end
                
                FOVring.Color = Color3.fromRGB(0, 255, 0)
                wait(0.1) -- Curto
                FOVring.Color = Color3.fromRGB(255, 0, 0)
            end
        end)
    elseif triggerConnection then
        triggerConnection:Disconnect()
        triggerConnection = nil
    end
end

-- Loop principal
RunService.RenderStepped:Connect(function()
    if not getgenv().AimbotEnabled then
        currentTarget = nil
        FOVring.Color = Color3.fromRGB(255, 0, 0)
        SetupNoRecoil() -- Desconecta recoil
        return
    end
    
    SetupTrigger()
    SetupNoRecoil() -- Configura recoil se ligado
    
    if getgenv().TriggerMode then
        -- No trigger, sem loop constante
        FOVring.Color = Color3.fromRGB(255, 0, 0)
        return
    end
    
    -- Modo normal: Snap bruto no loop
    local ClosestTarget = GetClosestTarget()
    if ClosestTarget and ClosestTarget.Character and ClosestTarget.Character:FindFirstChild(getgenv().AimPart) then
        if ClosestTarget.Character:FindFirstChild("Humanoid") and ClosestTarget.Character.Humanoid.Health <= 0 then
            currentTarget = nil
            return
        end
        currentTarget = ClosestTarget
        -- Posição direta, sem previsão
        local TargetPos = currentTarget.Character[getgenv().AimPart].Position
        local TargetCFrame = CFrame.new(Camera.CFrame.Position, TargetPos)
        
        -- Aplica snap
        if getgenv().SmoothnessAmount < 1 then
            Camera.CFrame = Camera.CFrame:Lerp(TargetCFrame, getgenv().SmoothnessAmount)
        else
            Camera.CFrame = TargetCFrame
        end
        
        FOVring.Color = Color3.fromRGB(0, 255, 0) -- Verde quando mirando
    else
        currentTarget = nil
        FOVring.Color = Color3.fromRGB(255, 0, 0)
    end
end)

-- Limpeza no unload (opcional)
game:BindToClose(function()
    if getgenv().HitboxEnabled then
        ExpandHitboxes(false)
    end
end)
